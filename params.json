{
  "name": "Sleuth",
  "tagline": "A Go library for master-less peer-to-peer autodiscovery and RPC between HTTP services",
  "body": "# sleuth <img src=\"https://cdn.rawgit.com/ursiform/sleuth/662e1c96d211b0d27c30fbfa043edc4b3bd6c35d/logo.svg\" height=\"50\" valign=\"middle\">\r\n[![API documentation](https://godoc.org/github.com/ursiform/sleuth?status.svg)](https://godoc.org/github.com/ursiform/sleuth) [![Coverage Status](https://coveralls.io/repos/github/ursiform/sleuth/badge.svg)](https://coveralls.io/github/ursiform/sleuth?branch=master)\r\n\r\n`sleuth` is a Go library that provides master-less peer-to-peer autodiscovery and RPC\r\nbetween HTTP services that reside on the same network. It works with minimal\r\nconfiguration and provides a mechanism to join a local network both as a\r\nclient that offers no services and as any service that speaks HTTP. Its\r\nprimary use case is for microservices on the same network that make calls to\r\none another.\r\n\r\nFor a full introduction and tutorial, check out: [Service autodiscovery in Go with sleuth](http://darian.af/post/master-less-peer-to-peer-micro-service-autodiscovery-in-golang-with-sleuth/)\r\n\r\n## Installation\r\n`sleuth` is dependent on [`libzmq`](https://github.com/zeromq/libzmq), which can be installed either from source or from binaries. For more information, please refer to [ØMQ: \"Get the Software\"](http://zeromq.org/intro:get-the-software) or the [`libzmq` repository](https://github.com/zeromq/libzmq).\r\n\r\nAnother option is to use a [Docker container that comes with Go and ZeroMQ](https://hub.docker.com/r/rxwen/golang-zeromq/).\r\n\r\nOnce `libzmq` is available on a system, `sleuth` can be installed like any other Go library:\r\n\r\n```\r\ngo get -u github.com/ursiform/sleuth\r\n```\r\n## API\r\nThe [`sleuth` API documentation is available on GoDoc](https://godoc.org/github.com/ursiform/sleuth) or you can simply run:\r\n\r\n```\r\ngodoc github.com/ursiform/sleuth\r\n```\r\n\r\n\r\n## Examples\r\n**Example (1):** The `echo-service` is a toy service that merely echoes back anything in an HTTP request body. It has made itself available on a `sleuth` network:\r\n```go\r\npackage main\r\n\r\nimport (\r\n  \"io/ioutil\"\r\n  \"net/http\"\r\n\r\n  \"github.com/ursiform/sleuth\"\r\n)\r\n\r\ntype echoHandler struct{}\r\n\r\nfunc (h *echoHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) {\r\n  body, _ := ioutil.ReadAll(req.Body)\r\n  res.Write(body)\r\n}\r\n\r\nfunc main() {\r\n  handler := new(echoHandler)\r\n  // In the real world, the Interface field of the sleuth.Config object\r\n  // should be set so that all services are on the same subnet.\r\n  config := &sleuth.Config{Handler: handler, Service: \"echo-service\"}\r\n  server, err := sleuth.New(config)\r\n  if err != nil {\r\n    panic(err.Error())\r\n  }\r\n  defer server.Close()\r\n  http.ListenAndServe(\":9873\", handler)\r\n}\r\n```\r\n\r\nAnd here is a trivial client that waits until it has connected to the network and found the `echo-service` to make a request before it exits. Note that the `*sleuth.Client` works as a drop-in replacement for an `*http.Client` when making requests using the `Do()` method:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"bytes\"\r\n\t\"fmt\"\r\n\t\"io/ioutil\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/ursiform/sleuth\"\r\n)\r\n\r\nfunc main() {\r\n\tservice := \"echo-service\"\r\n\t// In the real world, the Interface field of the sleuth.Config object\r\n\t// should be set so that all services are on the same subnet.\r\n\tconfig := &sleuth.Config{LogLevel: \"silent\"}\r\n\tclient, err := sleuth.New(config)\r\n\tif err != nil {\r\n\t\tpanic(err.Error())\r\n\t}\r\n\tdefer client.Close()\r\n\tclient.WaitFor(service)\r\n\tinput := \"This is the value I am inputting.\"\r\n\tbody := bytes.NewBuffer([]byte(input))\r\n\trequest, _ := http.NewRequest(\"POST\", \"sleuth://\"+service+\"/\", body)\r\n\tresponse, err := client.Do(request)\r\n\tif err != nil {\r\n\t\tpanic(err.Error())\r\n\t}\r\n\toutput, _ := ioutil.ReadAll(response.Body)\r\n\tif string(output) == input {\r\n\t\tfmt.Println(\"It works.\")\r\n\t} else {\r\n\t\tfmt.Println(\"It doesn't work.\")\r\n\t}\r\n}\r\n```\r\n\r\n---\r\n\r\n**Example (2):**  [`sleuth-example` is a fuller example of two services on a `sleuth` network](https://github.com/afshin/sleuth-example/) that need to communicate with each other.\r\n\r\nA complete tutorial based on that example can be found here: [Service autodiscovery in Go with sleuth](http://darian.af/post/master-less-peer-to-peer-micro-service-autodiscovery-in-golang-with-sleuth/).\r\n\r\n## Test\r\n    go test -cover github.com/ursiform/sleuth\r\n\r\n## Q & A\r\n**Q**: How does it work? I understand *what* `sleuth` does, but I want to know *how* it does it.\r\n\r\n**A**: Services that instantiate a `sleuth.Client` create an *ad hoc* [`Gyre`](https://github.com/zeromq/gyre) network. `Gyre` is the Go port of the [`Zyre`](https://github.com/zeromq/zyre) project, which is built on top of [ØMQ](https://github.com/zeromq/libzmq) (ZeroMQ). Nodes in the network discover each other using a UDP beacon on port `5670`. The actual communication between nodes happens on ephemeral `TCP` connections. What `sleuth` does is to manage this life cycle:\r\n* A peer joins the `Gyre` network as a member of the group `SLEUTH-v1`. If the peer offers a service, *i.e.*, if it has an [`http.Handler`](https://golang.org/pkg/net/http/#Handler), it notifies the rest of the network when it announces itself. The peer might have no service to offer, thus operating in client-only mode, or it may offer *one* service.\r\n* The peer finds other peers on the network. If you have asked the `sleuth` client to [`WaitFor()`](https://godoc.org/github.com/ursiform/sleuth#Client.WaitFor) one or more services to appear before continuing, that call will block until it has found those services.\r\n* If the peer is offering a service, `sleuth` automatically listens for incoming requests in a separate goroutine and responds to incoming requests by invoking the [`http.Handler`](https://golang.org/pkg/net/http/#Handler) that was passed in during instantiation.\r\n* When you make a request to an available service, `sleuth` marshals the request, sends it to one of the available peers that offers that service, and waits for a response. If the response succeeds, it returns an [`http.Response`](https://golang.org/pkg/net/http/#Response); if it times out, it returns an error. The `sleuth` client [`Do()`](https://godoc.org/github.com/ursiform/sleuth#Client.Do) method has the same signature as the `http` client [`Do()`](https://golang.org/pkg/net/http/#Client.Do) method in order to operate as a drop-in replacement.\r\n* When you want to *leave* the network, *e.g.*, when the application is quitting, the `sleuth` client [`Close()`](https://godoc.org/github.com/ursiform/sleuth#Client.Close) method immediately notifies the rest of the network that the peer is leaving. This is not strictly necessary because peers regularly check in to make sure the network knows they are alive, so the network automatically knows if a service has disappeared; but it is a good idea.\r\n\r\n---\r\n\r\n**Q**: What is the messaging protocol `sleuth` uses?\r\n\r\n**A**: Under the hood, `sleuth` marshals HTTP requests and responses into plain JSON objects and then compresses them via `gzip`. Instead of adding another dependency on something like Protocol Buffers, `sleuth` depends on the fact that most API responses between microservices will be fairly small and it leaves the door open to ports in a wide variety of languages and environments. One hard dependency seemed quite enough.\r\n\r\n---\r\n\r\n**Q**: What if I have multiple instances of the same service?\r\n\r\n**A**: Great! `sleuth` will automatically round-robin the requests each client makes to all services that share the same name.\r\n\r\n---\r\n\r\n**Q**: What happens if a service goes offline?\r\n\r\n**A**: Whenever possible, a service should call its client's [`Close()`](https://godoc.org/github.com/ursiform/sleuth#Client.Close) method before exiting to notify the network of its departure. But even if a service fails to do that, the `sleuth` network's underlying `Gyre` network will detect within about one second that a peer has disappeared. All requests to that service will be routed to other peers offering the same service. If no peers exist for that service, then requests (which are made by calling the `sleuth` client [`Do()`](https://godoc.org/github.com/ursiform/sleuth#Client.Do) method) will return an unknown service error (code `919`), which means that if you're already handling errors when making requests, you're covered.\r\n\r\n---\r\n\r\n**Q**: It doesn't work.\r\n\r\n**A**: That's not a question. But have you checked to make sure your firewall allows `UDP` traffic on port `5670`?\r\n\r\n---\r\n\r\n**Q**: It still doesn't work.\r\n\r\n**A**: That's still not a question. But have you set the `Interface` field of your [`sleuth.Config`](https://godoc.org/github.com/ursiform/sleuth#Config) object? The services you want to connect need to be on the same network and if you leave that field blank, the underlying `Gyre` network may not reside where you think it does. If you run `ifconfig` you'll get a list of available interfaces on your system.\r\n\r\n---\r\n\r\n**Q**: Why is it called `sleuth`?\r\n\r\n**A**: Because \"sleuth\" is the collective noun for a group of bears: the original reason for writing this library was to connect a group of [bear](https://github.com/ursiform/bear)/[forest](https://github.com/ursiform/forest) services. Also because a sleuth searches for things and discovers them. Hence the logo:\r\n\r\n<p align=\"center\">\r\n    <img src=\"https://cdn.rawgit.com/ursiform/sleuth/662e1c96d211b0d27c30fbfa043edc4b3bd6c35d/logo.svg\">\r\n</p>\r\n\r\n## License\r\n`sleuth` is licensed under the [MIT License](LICENSE).\r\n\r\nThe underlying libraries that `sleuth` relies on, [`Gyre`](https://github.com/zeromq/gyre) and [`libzmq`](https://github.com/zeromq/libzmq), are licensed under the [LGPL](http://www.gnu.org/licenses/lgpl-3.0.en.html). In effect, users who do not plan on modifying `Gyre` or `libzmq` can release their own applications under any license they see fit.\r\n\r\n## Resources\r\n\r\n* [API documentation](https://godoc.org/github.com/ursiform/sleuth)\r\n* [Service autodiscovery in Go with sleuth](http://darian.af/post/master-less-peer-to-peer-micro-service-autodiscovery-in-golang-with-sleuth/) (tutorial)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}